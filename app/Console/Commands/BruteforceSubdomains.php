<?php
/**
 * Author: Damian Schwyrz <mail@damianschwyrz.de>
 * URL: https://www.damianschwyrz.de
 * Copyright (c) 2018.
 */

namespace App\Console\Commands;

use App\Helper\FileHelper;
use App\Project;
use App\System\WildCardDomain;
use App\Target;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use LayerShifter\TLDExtract\Extract;
use Symfony\Component\Process\Process;

class BruteforceSubdomains extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'bruteforce:subdomains 
    {--project=0 : Project ID in system} 
    {--target= : Target domain, which you would like to append after the random subdomain string}
    {--timeout= : Timeout... after this second timer the while loops stops}
    {--imploder= : The char you want to use to implode subdomain parts, e.g. "." sub.sub.sub.domain.de or "-" for sub-sub-sub.domain.de}
    {--min_parts= : Min part count}
    {--max_parts= : Max part count} 
    {--rep_every_iteration=250 : Every Xth iteration to report... }
    {--wordlist_base=project : Wordlist base (project or all)}
    {--wordlist_base_bestcount=0 : How many subdomain parts to use? Best 2500? Best 100? 0=all}
    {--with_alt_dns=1 : Do you want to use altdns wordlist as addition to yours? }
    ';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Creates a list based on current active subdomains an combines them in random ways... stupid slow subdomain enumeration.';


    /**
     * @var \App\Project
     */
    protected $project;

    /**
     * @var \App\Target
     */
    protected $targets;

    /**
     * @var array
     */
    protected $parts = [];

    /**
     * @var int
     */
    protected $timeout;

    /**
     * @var int
     */
    protected $currentIteration = 0;

    /**
     * @var int
     */
    protected $foundNewSubdomainsCounter = 0;

    /**
     * @var array
     */
    protected $newSubdomains = [];

    /**
     * @var int
     */
    protected $min_parts;

    /**
     * @var int
     */
    protected $max_parts;

    /**
     * @var
     */
    protected $startTime;

    /**
     * @var string
     */
    protected $imploder = "";

    /**
     * @var int
     */
    protected $runTime = 0;

    /**
     * @var int
     */
    protected $moduloIteration = 250;

    /**
     * @var int
     */
    protected $processId;

    /**
     * @var array
     */
    protected $popularImploders = ['.', '-'];

    /**
     * @var string
     */
    protected $wordlistBase = "project";

    /**
     * @var int
     */
    protected $wordlistBaseBestCount = 2500;

    /**
     * @var bool
     */
    protected $withAltDnsList = true;

    /**
     * @var string
     */
    protected $cmd = "";

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();

        $this->timeout = config("toolset.artisan.bruteforce.subdomains.timeout");
        $this->min_parts = config("toolset.artisan.bruteforce.subdomains.min_parts");
        $this->max_parts = config("toolset.artisan.bruteforce.subdomains.max_parts");

        $this->startTime = time();

        $this->processId = mt_rand(10000, 99999);

    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {


        list($projectId, $domain) = $this->getArguments();

        $this->validateArguments($domain);


        $this->project = Project::findOrFail($projectId);

        $this->getWordlistBaseTargets();

        $this->wildCardDomainTest($domain);

        $this->extractSubdomainparts();

        $this->searchForHyphensInSdParts();

        $this->limitUsedSubdomainparts();

        $this->addAltDnsParts();

        $this->parts = array_unique($this->parts);
        sort($this->parts);
        $foundPartsCount = count($this->parts);

        $possibleSubdomains = pow($foundPartsCount, $this->max_parts);

        if ($this->imploder == "" && $this->max_parts > 1) {
            $possibleSubdomains = $possibleSubdomains * count($this->popularImploders);
        }

        $this->comment("Total different parts found: " . $foundPartsCount);
        $this->comment("Total combinations possible: " . $possibleSubdomains);

        $partsCount = $foundPartsCount - 1;

        while (true) {

            if (count($this->newSubdomains) >= $possibleSubdomains) {
                break;
            }

            $curPartCo = rand(
                $this->min_parts,
                $this->max_parts
            );

            $testDomain = $this->combineNewSubdomainBasedOnParts($curPartCo, $partsCount, $domain);


            if (isset($this->newSubdomains[$testDomain])) {
                continue;
            } else {
                $this->newSubdomains[$testDomain] = $testDomain;
            }

            $this->checkIfSubdomainIsValidAndExists(
                $testDomain,
                $projectId
            );

            $this->runTime = time() - $this->startTime;

            $this->printFoundSubdomains();

            if ($this->timeOutReached()) {
                $this->warn("timeout reached");
                break;
            }

            $this->currentIteration++;
        }


    }

    /**
     * @return array
     */
    protected function getArguments(): array
    {
        $projectId = $this->option("project");
        $domain = $this->option("target");

        if ($this->option("timeout") != "") {
            $this->timeout = trim($this->option("timeout"));
        }

        if ($this->option("min_parts") != "") {
            $this->min_parts = trim($this->option("min_parts"));
        }

        if ($this->option("max_parts") != "") {
            $this->max_parts = trim($this->option("max_parts"));
        }

        if ($this->option("imploder") != "") {
            $this->imploder = trim($this->option("imploder"));
        }

        if ($this->option("rep_every_iteration") != "") {
            $this->moduloIteration = intval($this->option("rep_every_iteration"));
        }

        $this->wordlistBase = trim($this->option("wordlist_base"));
        $this->wordlistBaseBestCount = intval($this->option("wordlist_base_bestcount"));

        $altdns = trim($this->option("with_alt_dns"));
        if ($altdns == "no" || $altdns == 0) {
            $this->withAltDnsList = false;
        }

        return [$projectId, $domain];
    }

    /**
     * @param $domain
     */
    protected function validateArguments(string $domain)
    {
        if ($domain == "") {
            $this->error("Domain empty!");
            exit();
        }

        if ($this->timeout <= 10) {
            $this->error("Timeout is way too short!");
            exit();
        }

        if ($this->min_parts <= 0) {
            $this->error("min_parts is too small!");
            exit();
        }

        if ($this->min_parts > $this->max_parts) {
            $this->error("min_parts has to be equal or smaller then max_parts");
            exit();
        }
    }

    private function getWordlistBaseTargets()
    {
        switch ($this->wordlistBase) {
            case 'all':
                $this->targets = Target::where("http_status", ">", 0)->get();
                break;
            case 'project':
            default:
                $this->targets = $this->project
                    ->targets()
                    ->where("http_status", ">", 0)
                    ->get();
        }
    }

    /**
     * @param $domain
     */
    protected function wildCardDomainTest(string $domain): void
    {
        $wildcard = new WildCardDomain($domain);
        $wildcard->test();

        if ($wildcard->isWildcardDomain()) {
            $message = "Wildcard domain detected... ";

            $this->error($message);

            exit();
        }
    }

    /**
     * Extracting a domain into its parts, we are interested in the subdomain, e.g.
     * www.origin.aws.domain.de -> parts: [www,origin,aws]
     *
     * Those parts are added to our parts array, in order to use them to brute force new subdomains.
     */
    protected function extractSubdomainparts()
    {
        $extract = new Extract();

        foreach ($this->targets as $target) {
            $result = $extract->parse($target->subdomain);
            $subDomainParts = $result->getSubdomains();

            if (is_null($subDomainParts)) {
                continue;
            }

            foreach ($subDomainParts as $part) {
                if (!in_array($part, $this->parts)) {
                    $this->parts[] = $part;
                }
            }

            if (is_null($target->cname) || $target->subdomain == $target->cname) {
                continue;
            }

            $result = $extract->parse($target->cname);
            $subDomainParts = $result->getSubdomains();

            if (is_null($subDomainParts)) {
                continue;
            }

            foreach ($subDomainParts as $part) {
                if (!in_array($part, $this->parts)) {
                    $this->parts[] = $part;
                }
            }
        }

    }

    /**
     * Sometimes a subdomain may look like this: www.test-demo.origin.domain.de, currently we have:
     * [www, test-demo, origin] in our parts array, but what we want is:
     * [www, test-demo, origin, test, demo]
     */
    protected function searchForHyphensInSdParts()
    {
        foreach ($this->parts as $partKey => $partValue) {

            if (strpos($partValue, "-") !== false) {

                $subStrings = explode("-", $partValue);

                foreach ($subStrings as $string) {

                    if (!isset($this->parts[$string])) {
                        $this->parts[] = $string;
                    }
                }
            }
        }
    }

    /**
     *
     */
    private function limitUsedSubdomainparts()
    {
        if ($this->wordlistBaseBestCount == 0) {
            return;
        }

        $partOccurenceCounter = [];

        foreach ($this->parts as $part) {
            if (isset($partOccurenceCounter[$part])) {
                $partOccurenceCounter[$part]++;
                continue;
            }

            $partOccurenceCounter[$part] = 1;
        }


        arsort($partOccurenceCounter);
        $this->parts = [];
        $currentIteration = 0;
        foreach ($partOccurenceCounter as $part => $occ) {
            if ($currentIteration == $this->wordlistBaseBestCount) {
                break;
            }
            $this->parts[] = $part;

            $currentIteration++;
        }

    }

    /**
     * Uses the words.txt from https://github.com/infosec-au/altdns to generate more subdomain parts.
     */
    private function addAltDnsParts()
    {
        if (!$this->withAltDnsList) {
            return;
        }

        $altDnsFile = base_path("toolset/wordlists/subdomains-altdns/words.txt");

        if (!File::exists($altDnsFile)) {
            return;
        }

        $fileContent = File::get($altDnsFile);
        $parts = FileHelper::splitContentByLines($fileContent);
        $this->parts = array_merge($this->parts, $parts);

    }

    /**
     * @param int    $curPartCo
     * @param int    $partsCount
     * @param string $domain
     *
     * @return string
     */
    protected function combineNewSubdomainBasedOnParts(int $curPartCo, int $partsCount, string $domain): string
    {
        $start = 0;

        $parts = [];

        while ($start < $curPartCo) {
            $randomWordIt = rand(0, $partsCount);
            $part = $this->parts[$randomWordIt];
            $parts[] = $part;
            $start++;
        }

        if ($this->imploder != "" || count($parts) == 1) {
            $subdomain = implode($this->imploder, $parts);
            $testDomain = $subdomain . "." . $domain;

            return $testDomain;
        }

        $countPopImploders = count($this->popularImploders) - 1;

        $newPart = [];

        foreach ($parts as $part) {
            $newPart[] = $part;
            $newPart[] = $this->popularImploders[rand(0, $countPopImploders)];
        }

        $subdomain = implode("", $newPart);
        $testDomain = $subdomain . "." . $domain;

        foreach ($this->popularImploders as $part) {
            $testDomain = str_replace($part . ".", ".", $testDomain);
        }

        return $testDomain;

    }

    /**
     * @param string $testDomain
     * @param int    $projectId
     *
     * @return bool
     */
    protected function checkIfSubdomainIsValidAndExists(string $testDomain, int $projectId)
    {

        $dig = rtrim("dig $testDomain A +short");
        $process = new Process($dig);
        $process->run();

        if (
            $process->getOutput() == ""
            || strpos($process->getOutput(), "invalid") !== false
            || strpos($process->getOutput(), "Usage:") !== false
        ) {
            return false;
        }


        $exists = Target::where("subdomain", $testDomain)->where("project_id", $projectId)->exists();

        if ($exists != 1) {
            $this->info("New: " . $testDomain);

            Target::create([
                'subdomain'  => $testDomain,
                'project_id' => $projectId,
                'status'     => "new",
            ]);

            $this->foundNewSubdomainsCounter++;
        }

    }

    /**
     *
     */
    protected function printFoundSubdomains()
    {
        if ($this->currentIteration == 0) {
            $this->currentIteration = 1;
        }

        if ($this->currentIteration % $this->moduloIteration === 0) {
            $runtime = number_format($this->runTime / $this->currentIteration, 2, ".", "");
            $this->warn("Process ID: " . $this->processId . " Iteration: " . $this->currentIteration . "\t\tFound: " . $this->foundNewSubdomainsCounter . "\t\tTime per iteration: " . $runtime . "s\t\tTime: " . $this->runTime . "s");
        }
    }

    /**
     * @return bool
     */
    protected function timeOutReached(): bool
    {
        return $this->runTime >= $this->timeout;
    }


}
