<?php
/**
 * Author: Damian Schwyrz <mail@damianschwyrz.de>
 * URL: https://www.damianschwyrz.de
 * Copyright (c) 2018.
 */

namespace App\Console\Commands;

use App\AdminNotice;
use App\Target;
use Carbon\Carbon;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Symfony\Component\Process\Process;

/**
 * Class makeAutoScreenshotsOfInterestingTargets
 * @package App\Console\Commands
 */
class makeAutoScreenshotsOfInterestingTargets extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'cronjob:make-screenshots-of-interesting-targets';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Take targets with status 0,2x,3x,40x,50x and make screenshots';

    /**
     * @var
     */
    protected $targets;

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $this->getTargets();

        AdminNotice::create([
            'type'    => 'warning',
            'context' => $this->signature,
            'message' => "Started with " . $this->targets->count() . " targets",
        ]);

        foreach ($this->targets as $target) {

            $url = $this->decideWhichUrlToUse($target);

            $this->line("Screenshot for: " . $url);

            $this->markTargetAsScreenshoted($target);

            list($outputFile, $outputPath) = $this->makeOutputFileAndPath($url, $target);

            $finaleCommand = $this->createCommand($url, $outputPath);

            $this->executeCmd($finaleCommand);

            if (!File::exists($outputPath)) {
                $message = "Failed to create screenshot";
                $this->warn($message);
                continue;
            }

            $this->saveImageToDb($outputFile, $target);


        }
    }

    private function getTargets()
    {
        $this->targets = Target::where('allow_regular_http_checks', 1)
            ->where(function ($query) {
                $query->lastScreenshotOlderThan(
                    config('ptm.cronjobs.auto_screenshots.days_between_checks')
                )->orWhereNull("autoFetchedScreenshot_at");
            })
            ->whereIn('http_status', [0, 200, 301, 302, 307, 401, 403, 404, 500, 502, 503])
            ->take(50)
            ->get();
    }

    /**
     * @param $target
     *
     * @return mixed
     */
    private function decideWhichUrlToUse(Target $target)
    {
        $url = $target->subdomain;

        if (!is_null($target->final_redirect_url)) {
            $url = $target->final_redirect_url;
        }

        return $url;
    }

    /**
     * @param $target
     */
    private function markTargetAsScreenshoted(Target $target)
    {
        $target->autoFetchedScreenshot_at = Carbon::now();
        $target->save();
    }

    /**
     * @param $url
     * @param $target
     *
     * @return array
     */
    private function makeOutputFileAndPath(string $url, Target $target): array
    {
        $outputFile = str_slug($url) . "-" . $target->id . ".jpeg";
        $outputPath = storage_path("app/public/screenshots/" . $outputFile);

        return [$outputFile, $outputPath];
    }

    /**
     * @param $url
     * @param $outputPath
     *
     * @return string
     */
    private function createCommand(string $url, string $outputPath): string
    {
        $cmd = [];

        $cmd[] = config('toolset.bin.phantomjs');
        $cmd[] = config("toolset.path.screenshottaker");
        $cmd[] = trim($url);
        $cmd[] = $outputPath;

        $finaleCommand = implode(" ", $cmd);

        return $finaleCommand;
    }

    /**
     * @param $finaleCommand
     */
    private function executeCmd(string $finaleCommand)
    {
        $process = new Process($finaleCommand);

        $process->setTimeout(
            config("toolset.screenshottaker.timeout")
        );

        $process->start();

        $process->wait(function ($type, $buffer) {
            if (Process::ERR === $type) {
                $this->error($buffer);
            } else {
                $this->line($buffer);
            }
        });
    }

    /**
     * @param $outputFile
     * @param $target
     */
    private function saveImageToDb($outputFile, $target)
    {
        $imageFile = asset('storage/screenshots/' . $outputFile);
        $target->screenshots = $imageFile;
        $target->save();
    }

}
